# 多级缓存实现商品详情页多维度化
### 1.维度化

- 将每个维度的数据都存一份,比如说商品维度的数据存一份,商品分类的数据存一份,商品店铺的数据存一份;那么在不同的维度数据更新的时候,只要去更新对应的维度缓存数据就可以了;
- 不同的维度,可以看做是不同的角度去观察一个东西,那么每个商品详情页中,都包含了不同的维度数据

``举个例子,如果不维度化,就导致多个维度的数据混合在一个缓存value中;但是不同维度的数据,可能更新的频率都大不一样;比如说,现在只是将1000个商品的分类批量调整了一下,但是如果商品分类的数据和商品本身的数据混杂在一起,那么可能导致需要将包括商品在内的大缓存value取出来,进行更新,再写回去,耗费大量的资源,redis压力也很大``

### 2.多级缓存

- 对于实时性要求不高的数据,比如说商品的基本信息,等等,我们采取的是三级缓存架构的技术方案,就是说由一个专门的数据生产的服务,去获取整个商品详情页需要的各种数据,经过处理后,将数据放入各级缓存中,每一级缓存都有自己的作用
- 每一层缓存在高并发的场景下,都有其特殊的用途,需要综合利用多级的缓存,才能支撑住高并发场景下各种各样的特殊情况

### 3.多级缓存架构

- Ehcache本地堆缓存
- Redis分布式缓存
- nginx本地缓存(本项目未涉及)

### 4.多级缓存实现细节

- 缓存数据生产服务监听多个kafka topic,每个kafka topic对应一个服务
- 如果一个商品信息服务发生了数据变更,那么就发送一个消息到kafka topic中
- 缓存数据生产服务监听到了消息以后,就发送请求到对应的商品信息服务中调用接口以及拉取数据,此时是从mysql中查询
- 缓存数据生产服务拉取到了数据之后,会将数据在本地缓存中写入一份,就是ehcache中,同时会将数据在redis中写入一份

### 5.分布式重建缓存的并发冲突问题
#### 5.1.缓存重建
- 数据在所有的缓存中都不存在了（LRU算法弄掉了）,就需要重新查询数据写入缓存,重建缓存
- 在不同的机器上,不同的服务实例中,数据在所有的缓存中都不存在了（LRU算法弄掉了）,就会出现多个机器分布式重建去读取相同的数据,然后写入缓存中

#### 5.2.缓存重建过程中多个服务实例并发冲突问题
- 这里采用zookeeper分布式锁

#### 5.3.实现细节
- 变更缓存重建以及空缓存请求重建,多个缓存服务更新redis缓存之前,都需要先获取对应商品id的分布式锁
- 拿到分布式锁之后,需要根据时间版本去比较一下,如果自己的版本新于redis中的版本,那么就更新,更新之后释放锁资源;否则就不更新
- 如果拿不到分布式锁,那么就等待,不断轮询等待,直到自己获取到分布式的锁

